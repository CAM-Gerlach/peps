PEP: 639
Title: Improving License Clarity with Better Package Metadata
Version: $Revision$
Last-Modified: $Date$
Author: Philippe Ombredanne <pombredanne at nexb.com>,
        C.A.M. Gerlach <CAM.Gerlach at Gerlach.CAM>
Sponsor: Paul Moore <p.f.moore at gmail.com>
PEP-Delegate: Paul Moore <p.f.moore at gmail.com>
Discussions-To: https://discuss.python.org/t/2154
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 15-Aug-2019
Post-History:
Resolution:


Abstract
========

This PEP defines a specification for how licenses are documented in the
core metadata via a new ``License-Expression`` field, with license expression
strings using SPDX identifiers [#spdxlist]_.

This will make license declarations simpler and less ambiguous for:

- package authors to create,
- package users to read and understand, and,
- tools to process package license information mechanically.

The PEP also proposes to:

- Deprecate the legacy ``License`` field and ``license ::`` classifiers.

- Formally specify a new ``License-File`` field, which is already used by
  ``wheel`` and ``setuptools`` to include license files in distributions.

- Define how tools can validate license expressions and handle errors and
  deprecated fields/classifiers to balance adoption of this PEP with
  backwards-compatibility and a smooth transition for package authors.

The changes in this PEP will update the core metadata format to version 2.3.


Goals
=====

This PEP's scope is limited strictly to how we document the license of a
distribution, specifically covering:

- An improved and structured way to document a license expression.
- A formal mechanism to include license texts in a built package.

The changes to the core metadata specification that this PEP requires have been
designed to minimize impact and maximize backward compatibility.
This specification builds off of existing ways to document licenses that are
in use in some tools (e.g. by adding the ``License-File`` field already used in
``wheel`` and ``setuptools``) and by some package authors (e.g. storing an SPDX
license expression in the existing ``License`` field).

In addition to these proposed changes, this PEP contains:

- Recommendations for publishing tools on how to validate the new
  ``License-Expression`` field and report informational warnings when a package
  uses legacy metadata (the ``License`` field and ``License ::`` classifers).

- Informational appendices that contain surveys of how we document licenses
  today in Python packages and elsewhere, and a reference Python library to
  parse, validate and build correct license expressions.

It is the intent of the PEP authors to work closely with tool authors to
implement the recommendations for validation and warnings specified in this PEP.


Non-Goals
=========

This PEP is neutral regarding the choice of license by any package author.

In particular, the SPDX license expression syntax proposed in this PEP provides
simpler and more expressive conventions to document accurately any kind of
license that applies to a Python package, whether it is an open source license,
a free or libre software license, a proprietary license, or a combination of
such licenses.

This PEP makes no recommendation for specific licenses and does not require the
use of specific license documentation conventions. This PEP also does not impose
any restrictions when uploading to PyPI.

Instead, it is intended to document best practices already in use, extend them
to use a new formally-specified and supported mechanism, and provide guidance
for packaging tools on how to hand the transition and inform users accordingly.

This PEP is not about license documentation in files inside packages,
though this is a surveyed topic in the appendix.


Possible Future PEPs
--------------------

It is the intention of the authors of this PEP to consider the submission of
related but separate PEPs in the future, which may include:

- Removing the deprecated ``License`` field and ``License ::``
  classifiers from the Core Metadata specification

- Making the ``License-Expression`` and ``License-File`` fields mandatory
  for publishing tools and PyPI packages.

- Requiring uploads to PyPI to use only FOSS (Free and Open Source Software)
  licenses.


Motivation
==========

Software is licensed, and providing accurate licensing information to Python
packages users is an important matter. Today, there are multiple places where
licenses are documented in package metadata and there are limitations to what
can be documented. This is often leading to confusion or a lack of clarity both
for package authors and package users.

Several package authors have expressed difficulty and/or frustrations due to the
limited capabilities to express licensing in package metadata. This also applies
to Linux and BSD* distribution packagers. This has triggered several
license-related discussions and issues, in particular:

- https://github.com/pypa/trove-classifiers/issues/17
- https://github.com/pypa/interoperability-peps/issues/46
- https://github.com/pypa/packaging-problems/issues/41
- https://github.com/pypa/wheel/issues/138
- https://github.com/pombredanne/spdx-pypi-pep/issues/1

On average, Python packages tend to have more ambiguous, or missing, license
information than other common application package formats (such as npm, Maven or
Gem) as can be seen in the statistics [#cdstats]_ page of the ClearlyDefined
[#cd]_ project that cover all packages from PyPI, Maven, npm and Rubygems.
ClearlyDefined is an open source project to help improve clarity of other open
source projects that is incubating at the OSI (Open Source Initiative) [#osi]_.


Rationale
=========

A mini-survey of existing license metadata definitions in use in the Python
ecosystem today and documented in several other system/distro and application
package formats is provided in Appendix 2 of this PEP.

There are a few takeaways from the survey:

- Most package formats use a single ``License`` field.

- Many modern package formats use some form of license expression syntax to
  optionally combine more than one license identifier together.
  SPDX and SPDX-like syntaxes are the most popular in use.

- SPDX license identifiers are becoming a de-facto way to reference common
  licenses everywhere, whether or not a license expression syntax is used.

- Several package formats support documenting both a license expression and the
  paths of the corresponding files that contain the license text. Most free and
  open source software licenses require package authors to include their full
  text in a distribution.

These considerations have guided the design and recommendations of this PEP.

The use of a new ``License-Expression`` field will provide an intuitive,
structured and unambiguous way to express the license of a distribution
using a well-defined syntax and well-known license identifiers.
Similarly, a formally-specified ``License-Files`` field offers a standardized
way to declare the full text of the license(s) as legally required to be
included with the package when distributed, and allows other tools consuming
the core metadata to unambiguously locate a distribution's license files.

Over time, encouraging the use of these fields and deprecating and ambiguous,
duplicative legacy alternatives will help Python software publishers improve
the clarity, accuracy and portability of their licensing practices,
to the benefit of package authors, consumers and redistributors alike.


Specification
=============

The changes necessary to implement the improved license handling outlined in
this PEP include those in both author-provided static source metadata, as
specified in PEP 621, and built package metadata, as defined in the Core
Metadata specification [#cms]_. Furthermore, requirements are needed for
tools handling and converting legacy license metadata to license expressions,
to ensure the results are consistent, correct and unambiguous.


Core Metadata
-------------

The canonical source for the names and semantics of each of the supported
metadata fields is the Core Metadata Specification [#cms]_ document.

This PEP adds the ``License-Expression`` and ``License-File`` fields,
deprecates the ``License`` field, and deprecates the ``License ::``
classifiers in the ``Classifier`` field.

As it adds new fields, this PEP updates the core metadata to version 2.3.


Add License-Expression Field
''''''''''''''''''''''''''''

The ``License-Expression`` optional field is specified to contain a text string
that is a valid SPDX license expression, defined below.

Publishing tools SHOULD issue an informational warning if this field is
missing, and MAY raise an error. Build tools MAY issue a similar warning,
but MUST NOT raise an error.

A license expression is a string using the SPDX license expression syntax as
documented in the SPDX specification [#spdx]_ using either Version 2.2
[#spdx22]_ or a later compatible version. SPDX is a working group at the Linux
Foundation that defines a standard way to exchange package information.

When used in the ``License-Expression`` field and as a specialization of the SPDX
license expression definition, a license expression can use the following license
identifiers:

- Any SPDX-listed license short-form identifiers that are published in the SPDX
  License List [#spdxlist]_, version 3.15 or any later compatible version.
  Note that the SPDX working group never removes any license identifiers;
  instead, they may choose to mark an identifier as "deprecated".

- The ``LicenseRef-Public-Domain`` and ``LicenseRef-Proprietary`` strings to
  identify licenses that are not included in the SPDX license list.

When processing the ``License-Expression`` field to determine if it contains
a valid license expression, build and publishing tools:

- SHOULD halt execution and raise an error if:

  - The field does not contain a valid license expression

  - One or more license identifiers are not valid (as defined above)

- SHOULD report an informational warning, and publishing tools MAY raise an
  error if one or more license identifiers have been marked as deprecated in
  the SPDX License List [#spdxlist]_.

- MUST store a case-normalized version of the ``License-Expression`` field
  using the reference case for each SPDX license identifier and
  uppercase for the ``AND``, ``OR`` and ``WITH`` keywords.

- SHOULD report an informational warning, and MAY raise an error if
  the normalization process results in changes to the
  ``License-Expression`` field contents.


Add License-File Field
''''''''''''''''''''''

The ``License-File`` optional field is specified to contain the string
representation of the path to a license-related file, relative to the
root license directory. Files specified under this field
could include license text, author/attribution information, or other
legal notices that need to be distributed with the package.
It is a multi-use field that may appear zero or more times,
each instance listing the path to one such file.

If a ``License-File`` is listed in a source or binary distribution's core
metadata, that file MUST be included in the distribution at the specified path
relative to the root license directory, and MUST be installed with the
distribution at that same path.

The root license directory is defined to be the project root directory
for source trees and source distributions, and the ``license_files``
subdirectory of the directory containing the core metadata (i.e. the
``.dist-info`` directory containing the ``METADATA`` file), for built
distributions and installed projects.

The specified relative path MUST be consistent between project source trees,
source distributions (sdists), binary distributions (wheels) and installed
projects. Therefore, inside the root license directory, packaging tools
MUST reproduce the directory structure under which the
source license files are located relative to the project root.

Path separators MUST be the forward slash character (``/``),
and parent directory indicators (``..``) MUST NOT be used.
License file content MUST be UTF-8 encoded text.

Build tools MAY and publishing tools SHOULD produce an informative warning
if a built package's metadata contains no ``License-File`` entries,
and publishing tools MAY but build tools MUST NOT raise an error.


Deprecate License Field
'''''''''''''''''''''''

The legacy unstructured-text ``License`` field is deprecated and replaced by
the new ``License-Expression`` field.

Build and publishing tools MUST raise an error if both fields are present and
their values are not identical, including capitalization and excluding
leading and trailing whitespace.

If only the ``License`` field is present, such tools SHOULD issue a warning
informing users it is deprecated and recommending ``License-Expression``
instead.

Along with license classifiers, the ``License`` field may be removed from a
new version of the specification in a future PEP.


Deprecate License Classifiers
'''''''''''''''''''''''''''''

Including license classifiers [#classif]_ (those beginning with ``License ::``)
in the ``Classifier`` field (described in PEP 301) is deprecated and
replaced by the more precise ``License-Expression`` field.

New ``License ::`` classifiers MUST NOT be added to PyPI [#classifersrepo]_;
users needing them SHOULD use the ``License-Expression`` field instead.
Along with the ``License`` field, license classifiers may be removed from a
new version of the specification in a future PEP.

If the ``License-Expression`` field is present, build tools MAY and publishing
tools SHOULD raise an error if one or more license classifiers (as defined
above) is included in a ``Classifier`` field, and not add such classifiers
themselves.

Otherwise, if this field contains a license classifier, build tools MAY
and publishing tools SHOULD issue a warning informing users such classifiers
are deprecated, and recommending ``License-Expression`` instead.
For compatibility with existing publishing and installation processes,
the presence of license classifiers SHOULD NOT raise an error unless
``License-Expression`` is also provided.


PEP 621 Source Metadata
-----------------------

As currently specified in the canonical PyPA specification [#projectspec]_,
PEP 621 defines how to declare a project's source metadata in a ``[project]``
table in the ``pyproject.toml`` file for packaging tools to consume and
output a distribution's core metadata.

This PEP adds the ``license-expression`` and ``license-files`` keys and
deprecates the ``license`` key.


Add license-expression Key
''''''''''''''''''''''''''

A new ``license-expression`` key is added to the ``project`` table, which has
a string value that is a valid SPDX license expression, as defined previously.
Its value maps to the ``License-Expression`` field in the core metadata.

Packaging tools SHOULD validate the expression as described above, outputting
an error or warning as specified. When generating the core metadata, tools
MUST perform case normalization.

If and only if the ``license-expression`` key is listed as ``dynamic``
(and is not specified), tools MAY infer a value for this field if they can do
so unambiguously, but MUST follow the provisions in the
`Converting Legacy Metadata`_ section.

If the ``license-expression`` key is present and valid (and the ``license``
key is not specified), for purposes of backward compatibility, tools MAY
back-fill the ``License`` core metadata field with the case-normalized value
of the ``license-expression`` key.


Add license-files Key
'''''''''''''''''''''

A new ``license-files`` key is added to the ``project`` table for specifying
paths in the project source relative to ``pyproject.toml`` to file(s)
containing licenses and other legal notices to be distributed with the package.
It corresponds to the ``License-File`` fields in the core metadata.

Its value may either be a table or an array of strings. If a table, it may
contain one of two optional, mutually exclusive keys, ``paths`` and ``globs``;
both arrays of strings. If both are specified, tools MUST raise an error.
The ``paths`` subkey contains verbatim file paths, and the ``globs`` subkey
valid glob patterns, parsable by the ``glob`` module [#globmodule]_ in the
Python standard library.

**Note**: To avoid ambiguity, confusion and (per PEP 20, the Zen of Python)
"more than one (obvious) way to do it", a flat array of strings value for the
``license-files`` key has been left out for now.

Path separators, if used, MUST be the forward slash character (``/``),
and parent directory indicators (``..``) MUST NOT be used.
Tools MUST assume that license file content is valid UTF-8 encoded text,
and SHOULD validate this and raise an error if it is not.

If the ``paths`` subkey is a non-empty array, packaging tools:

- MUST treat each value as a verbatim, literal file path, and
  MUST NOT treat them as glob patterns.

- MUST include each listed file in distribution artifacts.

- MUST NOT match any additional license files beyond those explicitly
  statically specified by the user under the ``paths`` key.

- MUST list each file path under a ``License-File`` field in the core metadata.

- MUST raise an error if one or more paths do not correspond to a valid file
  in the package source that can be copied into the built distribution.

If the ``globs`` subkey is a non-empty array, packaging tools:

- MUST treat each value as a glob pattern, and MUST raise an error if the
  pattern contains invalid glob syntax.

- MUST include all files matched by at least one listed pattern in
  distribution artifacts.

- MAY exclude files matched by glob patterns that can be unambiguously
  determined to be backup, temporary, hidden, OS-generated or VCS-ignored.

- MUST list each matched file path under a ``License-File`` field in the
  core metadata.

- SHOULD issue a warning and MAY raise an error if no files are matched.

- MAY issue a warning if any individual user-specified pattern
  does not match at least one file.

If the ``license-files`` key is present, and the ``paths`` or ``globs`` subkey
is set to a value of an empty array, then tools MUST NOT include any
license files and MUST NOT raise an error.

If the ``license-files`` key is not present and not explicitly marked as
``dynamic``, tools MUST assume a default value of the following::

    license-files.globs = ["LICEN[CS]E*", "COPYING*", "NOTICE*", "AUTHORS*"]

In this case, tools MAY issue a warning if no license files are matched,
but MUST NOT raise an error.

If the ``license-files`` key is marked as ``dynamic`` (and not present),
to preserve consistent behavior with current tools and help ensure the packages
they create are legally distributable, packaging tools SHOULD default to
including at least the license files matching the above patterns, unless the
user has explicitly specified their own.


Deprecate license Key
'''''''''''''''''''''

The ``license`` key in the ``project`` table is now deprecated.
It MUST not be used if either of the new ``license-expression`` or
``license-files`` keys are defined, nor should it be listed as ``dynamic``,
and packaging tools MUST raise an error if either is the case.

Otherwise, if the ``text`` key is present in the ``license`` table, tools
SHOULD issue a warning informing users it is deprecated and recommending the
``license-expression`` key instead.

Likewise, if the ``file`` key is present in the ``license`` table, tools SHOULD
issue a warning informing users it is deprecated and recommending
the ``license-files`` key instead. However, if the file is present in the
source, packaging tools SHOULD still use it to fill the ``License-File`` field
in the core metadata, and if so, MUST include the specified file in any
distribution artifacts for the project. If the file does not exist at the
specified path, tools SHOULD issue a warning, and MUST NOT fill it in a
``License-File`` field.

For backwards compatibility, to preserve consistent behavior with current tools
and ensure that users do not unknowingly create packages that are not legally
distributable, tools MUST assume the above default value for the
``license-files`` key and also include, in addition to the license file
specified under this ``file`` subkey, any license files that match the
corresponding list of patterns.

The ``license`` key may be removed from a new version of the specification
in a future PEP.


License Files In Project Formats
--------------------------------

A few minor additions will be made to the relevant existing specifications
to document, standardize and clarify what is already currently supported,
allowed and implemented behavior, as well as explicitly mention the directory
location the license file tree is rooted in for each format, per the
specification above.

Project source trees
  As described above, the project source metadata specification [#projectspec]_
  will be updated to reflect that license file paths MUST be relative to the
  project root directory; i.e. the directory containing the ``pyproject.toml``
  (or equivalently, other legacy project configuration,
  e.g. ``setup.py``, ``setup.cfg``, etc).

Source distributions (sdists)
  The sdist specification [#sdistspec]_ will be updated to reflect that for
  metadata version 2.3, the sdist MUST contain any license files specified
  by ``License-Files`` in the ``PKG-INFO`` at their respective paths relative
  to the top-level directory of the sdist
  (containing the ``pyproject.toml`` and the ``PKG-INFO`` core metadata).

Built distributions (wheels)
  The wheel specification [#wheelspec]_ will be updated to reflect that if
  the ``METADATA`` version is 2.3 or greater and one or more ``License-File``
  fields is specified, the ``.dist-info`` directory MUST contain a
  ``license_files`` subdirectory which MUST contain the files listed in the
  ``License-File`` fields in the ``METADATA`` file at their respective paths
  relative to the ``license_files`` directory.

Installed projects
  The recording installed projects specification [#installedspec]_ will be
  updated to reflect that if the ``METADATA`` version is 2.3 or greater
  and one or more ``License-File`` fields is specified, the ``.dist-info``
  directory MUST contain a ``license_files`` subdirectory which MUST contain
  the files listed in the ``License-File`` fields in the ``METADATA`` file
  at their respective paths relative to the ``license_files`` directory,
  and that any files in this directory MUST be copied from installed wheels.


Converting Legacy Metadata
--------------------------

If the contents of the ``License`` field are a valid SPDX expression containing
solely known, non-deprecated license identifiers, build and publishing tools MAY
use it to fill the ``License-Expression`` field.

Similarly, if the ``Classifier`` field contains exactly one license classifier
(those beginning with ``License ::``) that unambiguously maps to exactly one
valid, non-deprecated SPDX identifier, tools MAY use it to fill the
``License-Expression`` field.

If both a non-empty ``License`` field and a single license classifier are
present, the contents of the ``License`` field, including capitalization
(but excluding leading and trailing whitespace), MUST exactly match the SPDX
license identifier mapped to the license classifier to be considered
unambiguous for the purposes of automatically filling the
``License-Expression`` field.

If tools have filled the ``License-Expression`` field as described above,
they MUST output a prominent, user-visible warning informing package authors
of that fact, including the ``License-Expression`` string they have output,
and recommending that the source metadata be updated accordingly
with the indicated ``License-Expression``.

In any other case, tools MUST NOT use the contents of the ``License`` field
or license classifiers to fill the ``License-Expression`` field without
informing the user and requiring unambiguous, affirmative user action to
select and confirm the desired ``License-Expression`` value before proceeding.


Mapping License Classifiers to SPDX Identifiers
'''''''''''''''''''''''''''''''''''''''''''''''

Most single license classifiers (namely, all those not mentioned below)
map to a single valid SPDX license identifier, allowing tools to insert them
into the ``License-Expression`` field following the specification above.

Many legacy license classifiers intend to specify a particular license,
but do not specify the particular version or variant, leading to critical
ambiguity as to their terms, compatibility and acceptability [#issue17]_.
Tools MUST NOT attempt to automatically infer a ``License-Expression``
when one of these classifiers is used, and SHOULD instead prompt the user
to affirmatively select and confirm their intended license choice.

These classifiers are the following:

- ``License :: OSI Approved :: Academic Free License (AFL)``
- ``License :: OSI Approved :: Apache Software License``
- ``License :: OSI Approved :: Apple Public Source License``
- ``License :: OSI Approved :: Artistic License``
- ``License :: OSI Approved :: BSD License``
- ``License :: OSI Approved :: GNU Affero General Public License v3``
- ``License :: OSI Approved :: GNU Free Documentation License (FDL)``
- ``License :: OSI Approved :: GNU General Public License (GPL)``
- ``License :: OSI Approved :: GNU General Public License v2 (GPLv2)``
- ``License :: OSI Approved :: GNU General Public License v3 (GPLv3)``
- ``License :: OSI Approved :: GNU Lesser General Public License v2 (LGPLv2)``
- ``License :: OSI Approved :: GNU Lesser General Public License v2 or later (LGPLv2+)``
- ``License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)``
- ``License :: OSI Approved :: GNU Library or Lesser General Public License (LGPL)``

A comprehensive mapping of these classifiers to their possible specific
identifiers was assembled by Dustin Ingram [#badclassifiers]_, which tools
MAY use as a reference for the identifier selection options to offer users
when prompting the user to explicitly select the license identifier
they intended for their project.

**Note**: A couple additional classifiers, namely the "or later" variants of
the AGPLv3, GPLv2, GPLv3 and LGPLv3, are also listed in the aforementioned
mapping, but as they were merely proposed for textual harmonization and
still unambiguously map to their respective respective licenses,
they were not included here; LGPLv2 is, however, as it could ambiguously
refer to either the distinct v2.0 or v2.1 variants of that license.

In addition, for the various special cases, the following mappings are
considered canonical and normative for the purposes of this specification:

- Classifier ``License :: Public Domain`` MAY be mapped to the generic
  ``License-Expression: LicenseRef-Public-Domain``.
  If tools do so, they SHOULD issue an informational warning encouraging
  the use of more explicit and legally portable license identifiers
  such as ``CC0-1.0`` [#cc0]_ or the ``Unlicense`` [#unlic]_,
  since the meaning associated with the term "public domain" is thoroughly
  dependent on the specific legal jurisdiction involved,
  some of which lack the concept entirely.
  Alternatively, tools MAY choose to treat the above as ambiguous and
  require user confirmation to fill ``License-Expression`` in these cases.

- The generic and sometimes ambiguous classifiers
  ``License :: Free For Educational Use``,
  ``License :: Free For Home Use``,
  ``License :: Free for non-commercial use``,
  ``License :: Freely Distributable``,
  ``License :: Free To Use But Restricted``,
  ``License :: Freeware``, and
  ``License :: Other/Proprietary License`` MAY be mapped to the generic
  ``License-Expression: LicenseRef-Proprietary``,
  but tools MUST issue a prominent, informative warning if they do so.
  Alternatively, tools MAY choose to treat the above as ambiguous and
  require user confirmation to fill ``License-Expression`` in these cases.

- The generic and ambiguous classifiers ``License :: OSI Approved`` and
  ``License :: DFSG approved`` do not map to any license expression,
  and thus tools MUST treat them as ambiguous and require user intervention
  to fill ``License-Expression``.

- The classifiers ``License :: GUST Font License 1.0*`` and
  ``License :: GUST Font License 2006-09-30`` have no mapping to SPDX license
  identifiers and no PyPI package uses them, as of the writing of this PEP.
  Therefore, tools MUST treat them as ambiguous when attempting to fill
  ``License-Expression``.

When multiple license-related classifiers are used, their relation is ambiguous
and it is typically not possible to determine if all the licenses apply or if
there is a choice that is possible among the licenses. In this case, tools
MUST NOT automatically infer a license expression and SHOULD suggest that the
package author construct a license expression which expresses their intent.


Backwards Compatibility
=======================

Adding a new, dedicated ``License-Expression`` core metadata field and
``license-expression`` PEP 621 source metadata key unambiguously signals
support for the specification in this PEP. This avoids the risk of new tooling
misinterpreting a license expression as a free-form license description
or vice versa, and raises an error if and only if the user affirmatively
upgrades to the latest metadata version by adding said field/key.

The legacy ``License`` core metadata field and ``license`` PEP 621 source
metadata key will be deprecated along with the ``License ::`` classifiers,
retaining backwards compatibility while gently preparing users for their
future removal. Such a removal would follow a suitable transition period, and
be left to a future PEP and a new version of the core metadata specification.

Formally specifying the new ``License-File`` core metadata field and the
inclusion of the listed files in the distribution merely codifies and
refines the existing practices in popular packaging tools, including
``wheel`` and ``setuptools``, and is designed to be backwards-compatible
with their existing use of that field. Likewise, the new ``license-files``
PEP 621 source metadata key standardizes statically specifying the files
to include, as well as the default behavior, and allows other tools to
make use of them, while only having an effect once users and tools expressly
adopt it.


Security Implications
=====================

This PEP has no foreseen security implications: the License-Expression field is
a plain string and the License-File(s) are file paths. None of them introduces
any known new security concerns.


How to Teach This
=================

The simple cases are simple: a single license identifier is a valid license
expression and a large majority of packages use a single license.

The plan to teach users of packaging tools how to express their package's
license with a valid license expression is to have tools issue informative
messages when they detect invalid license expressions, or when the deprecated
``License`` field or a ``License ::`` classifier is used.

An immediate, descriptive error message if an invalid ``License-Expression``
is used will help users understand they need to use valid SPDX identifiers in
this field, and catch them if they make a mistake.
For authors still using the now-deprecated, less precise and more redundant
``License`` field or ``License ::`` classifiers, packaging tools will warn
them and inform them of the modern replacement, ``License-Expression``.
Finally, for users who may have forgot or not be aware they need to do so,
publishing tools will gently guide them toward including ``License-Expression``
and ``License-Files`` with their uploaded packages.

Tools may also help with the conversion and suggest a license expression in some
cases:

- The section `Mapping License Classifiers to SPDX Identifiers`_ provides
  tool authors with guidelines on how to suggest a license expression produced
  from legacy classifiers.

- Tools may also be able to infer and suggest how to update an existing
  ``License`` value and convert that to a ``License-Expression``.
  For instance, a tool may suggest converting from a ``License`` field with
  ``Apache2`` (which is not a valid license expression as defined in this PEP)
  to a ``License-Expression`` field with ``Apache-2.0`` (which is a valid license
  expression using an SPDX license identifier).


Reference Implementation
========================

Tools will need to support parsing and validating license expressions in the
``License-Expression`` field.

The ``license-expression`` library [#licexp]_ is a reference Python
implementation of a library that handles license expressions including parsing,
validating and formatting license expressions using flexible lists of license
symbols (including SPDX license identifiers and any extra identifiers referenced
here). It is licensed under the Apache-2.0 license and is used in a few projects
such as the SPDX Python tools [#spdxpy]_, the ScanCode toolkit [#scancodetk]_
and the Free Software Foundation Europe (FSFE) Reuse project [#reuse]_.


Rejected Ideas
==============

Core Metadata Fields
--------------------

Potential alternatives to the structure, content and deprecation of the
core metadata fields specified in this PEP.


Re-Use the License Field
''''''''''''''''''''''''

Following initial discussion [#reusediscussion]_, earlier versions of this
PEP proposed to re-use the existing ``License`` field, which tools would
attempt to parse as a SPDX expression with a fall back to treating as free
text. Initially, this would merely cause a warning (or even pass silently),
but would eventually be treated as an error by modern tooling.

This offered the benefit of greater backwards-compatibility,
easing the community into using SPDX expressions while taking advantage of
packages that already have them (either intentionally or coincidentally),
and avoided adding yet another license-related field.

However, following substantial discussion, consensus was reached that a
dedicated ``License-Expression`` field was the preferred overall approach.
The presence of this field is an unambiguous signal that a package
intends it to be interpreted as a valid SPDX identifier, without the need
for complex and potentially erroneous heuristics, and allows tools to
easily and unambiguously detect invalid content.

This avoids both false positive (``License`` values that a package author
didn't explicitly intend as an explicit SPDX identifier, but that happen
to validate as one), and false negatives (expressions the author intended
to be valid SPDX, but due to a typo or mistake is not), which are otherwise
not clearly distinguishable from true positives and negatives, an ambiguity
at odds with the goals of this PEP.

Furthermore, it allows both the existing ``License`` field and
the ``License::`` classifiers to be more easily deprecated,
with tools able to cleanly distinguish between packages intending to
affirmatively conform to the updated specification in this PEP or not,
and adapt their behavior (warnings, errors, etc) accordingly.
Otherwise, tools would either have to allow duplicative and potentially
conflicting ``License`` fields and classifiers, or warn/error on the
substantial number of existing packages that have SPDX identifiers as the
value for the ``License`` field, intentionally or otherwise (e.g. ``MIT``).

Finally, it avoids changing the behavior of an existing metadata field,
and avoids tools having to guess the ``Metadata-Version`` and field behavior
based on its value rather than merely its presence.

While this would mean the subset of existing projects containing ``License``
fields valid as SPDX expressions wouldn't automatically be recognized as such,
this only requires appending a few characters to the key name in the
package's source metadata, and this PEP provides extensive guidance on
how this can be done automatically by tooling.

Given all this, it was decided to proceed with defining a new,
purpose-created field, ``License-Expression``.


Re-Use the License Field with a Value Prefix
''''''''''''''''''''''''''''''''''''''''''''

As an alternative to the above, it was suggested to reduce the ambiguity
inherent in re-using the ``License`` field by prefixing SPDX expressions
with, e.g. ``spdx:``. However, this effectively amounted to creating a field
within a field, and doesn't address all the downsides of keeping the
``License`` field. Namely, it still changes the behavior of an
existing metadata field, requires tools to parse its value
to determine how to handle its content, and makes the specification and
deprecation process more complex and less clean.

Yet, it still shares a same main potential downside as just creating a new
field, that projects currently using valid SPDX identifiers in the ``License``
field, intentionally or not, won't be automatically recognized, and requires
about the same amount of effort to fix, namely changing a line in the
package's source metadata. Therefore, it was rejected in favor of a new field.


Don't Make License-Expression Mutually Exclusive
''''''''''''''''''''''''''''''''''''''''''''''''

For backwards compatibility, the ``License`` field and/or the license
classifiers could still be allowed together with the new
``License-Expression`` field, presumably with a warning. However, this
could easily lead to inconsistent, and at the very least duplicative
license metadata in no less than *three* different fields, which is
squarely contrary to the goals of this PEP of making the licensing story
simpler and unambiguous. Therefore, and in concert with clear community
consensus otherwise, this idea was soundly rejected.


Don't Deprecate Existing License Field and Classifiers
''''''''''''''''''''''''''''''''''''''''''''''''''''''

Several community members were initially concerned that deprecating the
existing ``License`` field and license classifiers would result in
excessive churn for existing package authors and raise the barrier to
entry for new ones, particularly everyday Python developers seeking to
package and publish their personal projects without necessarily caring
too much about the legal technicalities or being a "license lawyer".
Indeed, every deprecation comes with some non-zero short-term cost,
and should be carefully considered relative to the overall long-term
net benefit. And at the minimum, this change shouldn't make it more
difficult for the average Python developer to share their work under
a license of their choice, and ideally improve the situation.

Following many rounds of proposals, discussion and refinement,
the general consensus was clearly in favor of deprecating the legacy
means of specifying a license, in favor of "one obvious way to do it",
to improve the currently complex and fragmented story around license
documentation. Not doing so would leave three different un-deprecated ways of
specifying a license for a package, two of them ambiguous, less than
clear/obvious how to use, inconsistently documented and out of date.
This is more complex for for all tools in the ecosystem to support
indefinitely (rather than simply installers supporting older packages
implementing previous frozen metadata versions), resulting in a non-trivial
and unbounded maintenance cost.

Furthermore, it leads to a more complex and confusing landscape for users with
three similar but distinct options to choose from, particularly with older
documentation, answers and articles floating around suggesting different ones.
Of the three, ``License-Expression`` is the simplest and clearest to use
correctly; users just paste in their desired license identifier, or select it
via a tool, and they're done; no need to learn about Trove classifiers and
dig through the list to figure out which one(s) apply (and be confused
by many ambiguous options), or figure out on their own what should go
in the ``license`` field (anything from nothing, to the license text,
to a free-form description, to the same SPDX identifier they would be
entering in the ``License-Expression`` field anyway, assuming they can
easily find documentation at all about it). In fact, this can be
made even easier thanks to the new field. For example, GitHub's popular
ChooseALicense.com [#choosealicense]_ links to how to add SPDX license
identifiers to the packaging metadata of various languages that support
them right in the sidebar of every license page; the SPDX support in this
PEP enables adding Python to that list.

For current package maintainers who have specified a ``License`` or license
classifiers, this PEP only recommends warnings and prohibits errors for
all but publishing tools, which are allowed to error if their intended
distribution platform(s) so requires. Once maintainers are ready to
upgrade, for those already using SPDX expressions (accidentally or not)
this only requires appending a few characters to the key name in the
package's source metadata, and for those with license classifiers that
map to a single unambiguous license, or another defined case (public domain,
proprietary), they merely need to drop the classifier and paste in the
corresponding license identifier. This PEP provides extensive guidance and
examples, as will other resources, as well as explicit instructions for
automated tooling to take care of this with no human changes needed.
More complex cases where license metadata is currently specified may
need a bit of human intervention, but in most cases tools will be able
to provide a list of options following the mappings in this PEP, and
these are typically the projects most likely to be concerned about
licensing issues in any case, and thus most benefited by this PEP.

Finally, for unmaintained packages, those using tools supporting older
metadata versions, or those who choose not to provide license metadata,
no changes are required regardless of the deprecation.


PEP 621 License Key
-------------------

Alternate possibilities related to the ``License`` key in the
``pyproject.toml`` project source metadata specified in PEP 621.


Add Expression and Files Subkeys to Table
'''''''''''''''''''''''''''''''''''''''''

A previous working draft of this PEP added ``expression`` and ``files`` subkeys
to the existing ``license`` table in the PEP 621 source metadata, to parallel
the existing ``file`` and ``text`` subkeys. While this seemed perhaps the
most obvious approach at first, it had several serious drawbacks relative to
that ultimately taken here.

Most saliently, this means two very different types of metadata are being
specified under the same top-level key that require very different handling,
and furthermore, unlike the previous arrangement, the keys were not mutually
exclusive and can both be specified at once, and with some subkeys potentially
being dynamic and others static, and mapping to different core metadata fields.
This also breaks from the consensus for the core metadata fields, namely to
separate the license expression into its own explicit field.

Furthermore, this leads to a conflict with marking the field as ``dynamic``
(assuming that is intended to specify PEP 621 keys, as that PEP seems to rather
imprecisely imply, rather than core metadata fields), as either both would have
to be treated as ``dynamic``. A user may want to specify the ``expression``
key as ``dynamic``, if they intend their tooling to generate it automatically;
conversely, they may rely on their build tool to dynamically detect license
files via means outside of that strictly specified here. And indeed, current
users may mark the present ``license`` key as ``dynamic`` to automatically
fill it in the metadata. Grouping all these uses under the same key forces an
"all or nothing" approach, and creates ambiguity as to user intent.

There are further downsides to this as well. Both users and tools would need to
keep track of which fields are mutually exclusive with which of the others,
greatly increasing cognitive and code complexity, and in turn the probability
of errors. Conceptually, juxtaposing so many different fields under the
same key is rather jarring, and leads to a much more complex mapping between
PEP 621 keys and core metadata fields, not in keeping with PEP 621.
This causes the PEP 621 naming and structure to diverge further from
both the core metadata and native formats of the various popular packaging
tools that use it. Finally, this results in the spec being significantly more
complex and convoluted to understand and implement than the alternatives.

The approach this PEP now takes, adding distinct ``license-expression`` and
``license-file`` keys and simply deprecating the whole ``license`` key, avoids
all the issues identified above, and results in a much clearer and cleaner
design overall. It allows ``license`` and ``license-files`` to be tagged
``dynamic`` independently, separates two independent types of metadata
(syntactically and semantically), restores a closer to 1:1 mapping of
PEP 621 keys to core metadata fields, automatically makes
``License-Expression`` exclusive of the deprecated and conflicting
``file`` and ``text`` subkeys, and reduces nesting by a level for both.
Other than adding two extra keys to the file, there was no real apparent
downside to this latter approach, so it was adopted for this PEP.


Define License Expression as String Value
'''''''''''''''''''''''''''''''''''''''''

A compromise approach between adding two new top-level keys for license
expressions and files would be to add a separate ``license-files`` key,
but re-using the ``license`` key for the license expression, either by
defining it as the (previously reserved) string value for the ``license``
key, retaining the ``expression`` sub-key in the ``license`` table, or
allowing both. Indeed, this would seem to have been envisioned by PEP 621
itself with this PEP in mind, in particular the first approach::

    A practical string value for the license key has been purposefully left out
    to allow for a future PEP to specify support for SPDX [6] expressions.

However, while a working draft temporarily explored this solution, it was
ultimately rejected, as it shared most of the downsides identified with
adding new subkeys under the existing ``license`` table, as well as several
of its own, with again minimal advantage over separating both.

In particular, it means the top-level ``license`` key still maps to multiple
core metadata fields with different purposes and interpretation (``License``
and ``License-Expression``), one deprecated and one new, and still prevents
them from being separately marked as dynamic, and conflates the same with
an existing mark. This further exhibits the same divergence from both
PEP 621, core metadata, tool file formats and the consensus in the discussion
in not making the new license expression map to a corresponding new field,
none of which was the case at the time PEP 621 was drafted.
Finally, this would deny a clear separation from the old behavior by not
cleanly deprecating the entire ``license`` field, and increases the complexity
of the specification and implementation.

In addition to the aforementioned issues, this also requires deciding between
the three individual approaches (``expression`` subkey, top-level string or
allowing both), all of which have further significant downsides and none of
which are clearly superior or more obvious, leading to needless bikeshedding.

If the license expression was made the string value of the ``license`` key,
as reserved by PEP 621, it would be slightly shorter for users to type and
more obviously the preferred approach. However, it is far *less* obvious that
it is a license expression at all, to authors and those viewing the files,
and this lack of clarity, explicitness, ambiguity and potential for user
confusion is exactly what this PEP seeks to avoid, all to save a few characters
over other approaches.

If an ``expression`` key was added to the ``license`` table, it would retain
the clarity of a new top-level field, but add additional complexity for no
real benefit, with an extra level of nesting, and users and tools needing to
deal with the mutual exclusivity of the keys, as before. And allowing both
(as a table key *and* the string value) would inherit both's downsides,
while adding even more spec and tool complexity and making there more than
"one obvious way to do it", further potentially confusing users.

Therefore, a separate top-level ``license-expression`` key was adopted to avoid
all these issues, with relatively minimal downside aside from adding a single
additional top-level key and (versus some approaches) a few extra characters
to type.


Add a Type Key to Treat as Expression
'''''''''''''''''''''''''''''''''''''

Instead of creating a new top-level ``license-expression`` key in the
PEP 621 source metadata, we could add a ``type`` key to the existing
``license`` table to control whether ``text`` (or a string value)
is interpreted as free-text or a license expression. This could make
backward compatibility a little more seamless, as older tools could ignore
it and always treat ``text`` as ``license``, while newer tools would
know to treat it as a license expression, if ``type`` was set appropriately.
Indeed, PEP 621 suggests something of this sort as a possible alternative
way that SPDX expressions could be implemented.

However, all the same downsides as in the previous item apply here,
including greater complexity, a more complex mapping between the project
source metadata and core metadata and inconsistency between the presentation
in tool config, PEP 621 and core metadata, a much less clean deprecation,
further bikeshedding over what to name it, and inability to mark one but
not the other as dynamic, among others.

In addition, while theoretically potentially a little easier in the short
term, in the long term it would mean users would always have to remember
to specify the correct ``type`` to ensure their license expression is
interpreted correctly, which adds work and potential for error; we could
never safety change the default while being confident that users
understand that what they are entering is unambiguously a license expression,
with all the false positive and fales negative issues as above.

Therefore, for these as well as the same reasons this approach was rejected
for the core metadata in favor of a distinct ``License-Expression`` field,
we similarly reject this here.


Must be Marked Dynamic to Back-Fill
'''''''''''''''''''''''''''''''''''

The ``license`` key in the ``pyproject.toml`` could be required to be
explicitly set to dynamic in order for the ``License`` core metadata field
to be automatically back-filled from the value of the ``license-expression``
key. This would be more explicit that the filling will be done, as strictly
speaking the ``license`` key is not (and cannot be) specified in
``pyproject.toml``.

However, this isn't seen to be necessary, because it is simply using the
static, verbatim literal value of the ``license-expression`` key, as specified
strictly in this PEP. Therefore, any conforming tool can trivially,
deterministically and unambiguously derive this using only the static data
in the ``pyproject.toml`` file itself.

Furthermore, this actually adds significant ambiguity, as it means the value
could get filled arbitrarily by other tools, which would in turn compromise
and conflict with the value of the new ``License-Expression`` field, which is
why such is explicitly prohibited by this PEP. Therefore, not marking it as
``dynamic`` will ensure it is only handled in accordance with this PEP's
requirements.

Finally, users explicitly being told to mark it as ``dynamic``, or not, to
control filling behavior is both a mis-use of the ``dynamic`` field as
apparently intended, and prevents tools from adapting to best practices
(fill, don't fill, etc) as they develop and evolve over time.


PEP 621 License-Files Key
-------------------------

Alternatives considered for the ``License-Files`` key in the
``pyproject.toml`` project source metadata, primarily related to the
path/glob type handling.


Add a Type Key to Control Path/Glob
'''''''''''''''''''''''''''''''''''

Instead of defining mutually exclusive ``paths`` and ``globs`` subkeys
of the ``license-files`` PEP 621 project metadata key, we could
achieve the same effect with a ``files`` key for the list and
a ``type`` key for how to interpret it. However, the latter offers no
real advantage over the former, in exchange for requiring more keystrokes,
verbosity and complexity, as well as less flexibility in allowing both,
or another additional key in the future, as well as the need to bikeshed
over the key name. Therefore, it was summarily rejected.


Only Accept Verbatim Paths
''''''''''''''''''''''''''

Globs could be disallowed completely as values to the ``license-files``
key in ``pyproject.toml`` and only verbatim literal paths allowed.
This would ensure that all license files are explicitly specified, all
specified license files are found and included, and the source metadata
is completely static in the strictest sense of the term, without tools
having to inspect the rest of the package files to determine exactly
what license files will be included and what the ``License-Files`` values
will be. This would also modestly simplify the spec and tool implementation.

However, practicality once again beats purity here. Globs are supported and
used by many existing tools for finding license files, and explicitly
specifying the full path to every license file would be unnecessarily tedious
for more complex projects with vendored code and dependencies. More
critically, it would make it much easier to accidentally miss a required
legal file, silently rendering the package illegal to distribute.

Tools can still statically and consistently determine the files to be included,
based only on those glob patterns the user explicitly specified and the
filenames in the package, without installing it, executing its code or even
examining its files. Furthermore, tools are still explicitly allowed to warn
if specified glob patterns (including full paths) don't match any files.
And, of course, sdists, wheels and others will have the
full static list of files specified in their core metadata.

Perhaps most importantly, this would also preclude the currently specified
default value, as widely used by the current most popular tools, and thus
be a major break to backward compatibility, tool consistency, and safe
and sane default functionality to avoid unintentional license violations.
And of course, authors are welcome and encouraged to specify their license
files explicitly via the ``files`` table key, once they are aware of it and
if it is suitable for their project and workflow.


Only Accept Glob Patterns
'''''''''''''''''''''''''

Conversely, all ``License-Files`` strings could be treated as glob patterns.
This would slightly simplify the spec and implementation, avoid an extra level
of nesting, and more closely match the configuration format of existing tools.

However, for the cost of a few characters, it ensures users are aware
whether they are entering globs or verbatim paths. Furthermore, allowing
license files to be specified as literal paths avoids edge cases, such as those
containing glob or other special characters (or those confusingly or even
maliciously similar to them, as described in PEP 672).

Including an explicit ``paths`` value guarantees that the resulting
``License-File`` metadata is correct, complete and purely static in the
strictest sense of the term, with all license paths explicitly specified
in the ``pyproject.toml`` file, guaranteed to be included and with an early
error should any be missing.

This allows tools to locate them and know the exact values of the
``License-File`` core metadata fields without having to traverse the
source files of the project and match globs, potentially allowing easier,
more efficient and reliable inspection by tools.

Therefore, given the relatively small cost and the significant benefits,
this approach was not adopted.


Infer Whether Paths or Globs
''''''''''''''''''''''''''''

It was considered whether to simply allow specifying an array of strings
directly for the ``license-file`` key, rather than making it a table with
explicit ``paths`` and ``globs``. This would be somewhat simpler and avoid
an extra level of nesting, and more closely match the configuration format
of existing tools. However, it was ultimately rejected in favor of separate,
mutually exclusive ``paths`` and ``globs`` table keys.

In practice, it only saves six extra characters in the ``pyproject.toml``
(``license-files = [...]`` vs ``license-files.globs = [...]``), but allows
the user to more explicitly declare their intent, ensures they understand how
the field is going to be interpreted, and serves as an unambiguous indicator
for tools to parse them as globs rather than verbatim path literals.

This, in turn, allows for more appropriate, clearly specified tool
behaviors for each case, many of which would be unreliable or impossible
without it, to avoid common traps, provide more helpful feedback and
behave more sensibly and intuitively overall. These include, with ``files``,
guaranteeing that each and every specified file is included and immediately
raising an error if one is missing, and with ``globs``, checking glob syntax,
excluding unwanted backup, temporary, or other such files (as current tools
already do), and optionally warning if a glob doesn't match any files.
This also avoids edge cases (e.g. paths that contain glob characters) and
reliance on heuristics to determine interpretation—the very thing this PEP
seeks to avoid.


Also Allow a Flat Array Value
'''''''''''''''''''''''''''''

Initially, after deciding to define ``license-files`` as a table of ``paths``
and ``globs``, thought was given to making a top-level string array under the
``license-files`` key mean one or the other (probably ``globs``, to match most
current tools). This is slightly shorter and simpler, would allow gently
nudging users toward a preferred one, and allow a slightly cleaner handling of
the empty case (which, at present, is treated identically for either).

However, this again only saves six characters in the best case, and there
isn't an obvious choice; whether from a perspective of preference (both had
clear use cases and benefits), nor as to which one users would naturally
assume.

Flat may be better than nested, but in the face of ambiguity, users
may not resist the temptation to guess. Requiring users to explicitly specify
one or the other ensures they are aware of how their inputs will be handled,
and is more readable for others, both human and machine alike. It also makes
the spec and tool implementation slightly more complicated, and it can always
be added in the future, but not removed without breaking backward
compatibility. And finally, for the "preferred" option, it means there is
more than one obvious way to do it.

Therefore, per PEP 20, the Zen of Python, this approach is hereby rejected.


Allow Both Paths and Globs Keys
'''''''''''''''''''''''''''''''

Allowing both ``paths`` and ``globs`` keys to be specified under the
``license-files`` table was considered, as it could potentially allow
more flexible handling for particularly complex projects, and specify on a
per-pattern rather than overall basis whether ``license-files`` entries
should be treated as ``paths`` or ``globs``.

However, given the existing proposed approach already matches or exceeds the
power and capabilities of those offered in tools' config files, there isn't
clear demand for this and few likely cases that would benefit, it adds a large
amount of complexity for relatively minimal gain, in terms of the
specification, in tool implementations and in ``pyproject.toml`` itself.

There would be many more edge cases to deal with, such as how to handle files
matched by both lists, and it conflicts in multiple places with the current
specification for how tools should behave with one or the other, such as when
no files match, guarantees of all files being included and of the file paths
being explicitly, statically specified, and others.

Like the previous, if there is a clear need for it, it can be always allowed
in the future in a backward-compatible manner (to the extent it is possible
at all), while the same is not true of disallowing it. Therefore, it was
decided to require the two keys to be mutually exclusive.


Rename Paths Subkey to Files
''''''''''''''''''''''''''''

Initially, it was considered whether to name the ``paths`` subkey of the
``license-files`` table ``files`` instead. However, ``paths`` was ultimately
chosen, as calling the table key ``files`` resulted in duplication between
the table name (``license-files``) and the subkey name (``files``), i.e.
``license-files.files = ["LICENSE.txt"]``, made it seem like the preferred/
default subkey when it was not, and lacked the same parallelism with ``globs``
in describing the format of the string entry rather than what was being
pointed to.


Must be Marked Dynamic to Use Defaults
''''''''''''''''''''''''''''''''''''''

It may seem outwardly sensible, at least with a particularly restrictive
interpretation of PEP 621 's description of the ``dynamic`` field, to
consider requiring the ``license-files`` key to be explicitly marked as
``dynamic`` in order for the default glob patterns to be used, or alternatively
for license files to be matched and included at all.

However, this is merely declaring a static, strictly-specified default value
for this particular key, required to be used exactly by all conforming tools
(so long as it is not marked ``dynamic``, negating this argument entirely),
and is no less static than any other set of glob patterns. Furthermore, the
resulting ``License-File`` core metadata values can still be determined with
only a list of files in the source, without installing or executing any of the
code, or even inspecting file contents.

Moreover, even if this were not so, practicality would trump purity, as this
interpretation would be strictly backwards-incompatible with the existing
format, as it would trigger inconstant behavior with the existing tools.
Further, this would create a very serious and likely risk of a large number of
projects unknowingly no longer including legally mandatory license files,
making their distribution illegal, and is thus not a sane, much less sensible
default.

Finally, aside from adding an additional line of virtually-required boilerplate
to the file, not defining the default as dynamic allows authors to clearly
and unambiguously indicate when their build/packaging tools are going to be
handling the inclusion of license files themselves rather than strictly
conforming to the PEP 621 portions of this PEP; to do otherwise would defeat
the primary purpose of the ``dynamic`` field as a marker and escape hatch.


License File Paths
------------------

Alternatives related to the paths and locations of license files in the source
and built distributions.


Flatten License Files in Subdirectories
'''''''''''''''''''''''''''''''''''''''

Previous drafts of this PEP were silent on the issue of handling license files
in subdirectories. Currently, Wheel [#wheelfiles]_ and (following its example)
Setuptools [#setuptoolsfiles]_ flattens all license files into the
``.dist-info`` directory [#setuptoolsfiles]_, without preserving the source
subdirectory hierarchy.

While this is the simplest approach and matches existing ad hoc practice,
this can result in name conflicts and license files clobbering others,
with no obvious defined behavior for how to resolve them, and leaving the
package legally un-distributable without any clear indication to users that
their specified license files have not been included.

Furthermore, this leads to inconsistent relative file paths for non-root
license files between the source, sdist and wheel, and prevents the paths
given in the PEP 621 "static" metadata from being truly static, as they need
to be flattened, and may potentially overwrite one another. Finally,
the source directory structure often implies valuable information about
what the licenses apply to, and where to find them in the source,
which is lost when flattening them and far from trivial to reconstruct.

To resolve this, the PEP now proposes, as did contributors on both of the
above issues, reproducing the source directory structure of the original
license files inside the ``.dist-info`` directory. This would fully resolve the
concerns above, with the only downside being a more nested ``.dist-info``
directory. There is still a risk of filename collision with
edge-case custom filenames (e.g. ``RECORD``, ``METADATA``), but that is also
the case with the previous approach, and in fact with fewer files flattened
into the root, this would actually reduce the risk. Furthermore,
a followup proposal rooting the license files under a ``license_files``
subdirectory eliminates both collisions and the clutter problem entirely.


Resolve Name Conflicts Differently
''''''''''''''''''''''''''''''''''

Rather than preserving the source directory structure for license files
inside the ``.dist-info`` directory, we could specify some other mechanism
for conflict resolution, such as pre- or appending the parent directory name
to the license filename, traversing up the tree until the name was unique,
to avoid excessively nested directories.

However, this would not address the path consistency issues, would require
much more discussion, coordination and bikeshedding, and further complicate
the specification and the implementations. Therefore, it was rejected in
favor of the simpler and more obvious solution of just preserving the
source subdirectory layout, as many stakeholders have already advocated for.


Dump Directly in Dist-Info
''''''''''''''''''''''''''

Previously, the included license files were stored directly in the top-level
``.dist-info`` directory of built wheels and installed projects. This followed
existing ad hoc practice, ensured most existing wheels currently using this
feature will match new ones (i.e. those projects built with Wheel versions
that include license files but don't specify license files in subdirectories),
and kept the specification simpler, with the license files always being
stored in the same location relative to the core metadata regardless of
distribution type.

However, this leads to a more cluttered ``.dist-info`` directory, littered
with arbitrary license files and subdirectories, as opposed to separating
licenses into their own namespace (which per the Zen of Python, PEP 20, are
"one honking great idea"). While currently small, there is still a
risk of collision with specific custom license filenames
(e.g. ``RECORD``, ``METADATA``) in the ``.dist-info`` directory, which
would only increase if and when additional files were specified here, and
would require carefully limiting the potential filenames used to avoid
likely conflicts with those of license-related files. Finally,
putting licenses into their own specified subdirectory would allow
humans and tools to quickly, easily and correctly list, copy and manipulate
all of them at once (such as in distro packaging, legal checks, etc)
without having to reference each of their paths from the core metadata.

Therefore, now is a prudent time to specify an alternate approach.
The simplest and most obvious solution, as suggested by several on the Wheel
and Setuptools implementation issues, is to simply root the license files
relative to a ``license_files`` subdirectory of ``.dist-info``. This is simple
to implement and solves all the problems noted above, without clear significant
drawbacks relative to other more complex options.

It does make the specification a bit more complex and less elegant, but
implementation should remain equally simple. It does mean that wheels
produced with following this change will have differently-located licenses
than those prior, but as this was already true for those in subdirectories,
and until this PEP there was no way of discovering these files or
accessing them programmatically, this doesn't seem likely to pose
significant problems in practice. Given this will be much harder if not
impossible to change later, once the status quo is standardized, tools are
relying on the current behavior and there is much greater uptake of not
only simply including license files but potentially accessing them as well
using the core metadata, if we're going to change it, now would be the time
(particularly since we're already introducing an edge-case change with how
license files in subdirs are handled, as well as other things).

Therefore, the latter has been incorporated into current drafts of this PEP.


Add New Licenses Category to Wheel
''''''''''''''''''''''''''''''''''

Instead of defining a root license directory (``license_files``) inside
the core metadata directory (``.dist-info``) for wheels, we could
instead define a new category (and, presumably, a corresponding install scheme),
similar to the others currently included under ``.data`` in the wheel archive,
specifically for license files, called (e.g.) ``licenses``. This was mentioned
by the wheel creator, and would allow installing licenses somewhere more
platform-appropriate and flexible than just the ``.dist-info`` directory
in the site path, and potentially be conceptually cleaner than including
them there.

However, at present, this PEP does not implement this idea, and it is
deferred to a future one. It would add significant complexity and friction
to this PEP, being primarily concerned with standardizing existing practice
and updating the core metadata specification. Furthermore, doing so would
likely require modifying ``sysconfig`` and the install schemes specified
therein, alongside Wheel, Installer and other tools, which would be a
non-trivial undertaking. While potentially slightly more complex for
repackagers (such as those for Linux distributions) the current proposal
ensuring all license files are included, and in a single dedicated directory
(which can easily be copied or relocated downstream), should still greatly
improve the status quo in this regard without the attendant complexity.

In addition, this approach is not fully backwards compatible (since it
isn't transparent to tools that simply extract the wheel), is a greater
departure from existing practice and would lead to more inconsistent
license install locations from wheels of different versions. Finally,
this would mean licenses were not installed as proximately to their
associated code, there would be more variability in the license root path
across platforms and between built and installed packages, accessing
installed licenses pro grammatically would be more non-trivial, and a
suitable install location and method would need to be created, discussed
and decided that would avoid name clashes.

Therefore, to keep this PEP in scope, the current approach was retained.


Name the Subdirectory Licenses
''''''''''''''''''''''''''''''

Both ``licenses`` and ``license_files`` have been suggested as potential
names for the root license directory inside ``.dist-info`` of wheels and
installed projects. The former is slightly shorter, but the latter is
more clear and unambiguous regarding its contents, and is consistent with
the name of the core metadata field (``License-File``) and the PEP 621
project source metadata key (``License-Files``). Therefore, the latter
was chosen instead.


Other Ideas
-----------

Miscellaneous proposals, possibilities and discussion points that were
ultimately not adopted.


Map Identifiers to License Files
''''''''''''''''''''''''''''''''

This would require using a mapping (two parallel lists would be too prone to
alignment errors) and a mapping would bring extra complication to how license
are documented by adding an additional nesting level.

A mapping would be needed as you cannot guarantee that all expressions (e.g.
GPL with an exception may be in a single file) or all the license keys have a
single license file and that any expression does not have more than one. (e.g.
an Apache license ``LICENSE`` and its ``NOTICE`` file for instance are two
distinct files). Yet in most cases, there is a simpler "one license", "one or
more license files". In the rarer and more complex cases where there are many
licenses involved you can still use the proposed conventions at the cost of a
slight loss of clarity by not specifying which text file is for which license
identifier, but you are not forcing the more complex data model (e.g. a mapping)
on everyone that may not need it.

We could of course have a data field with multiple possible value types (it's a
string, it's a list, it's a mapping!) but this could be a source of confusion.
This is what has been done for instance in npm (historically) and in Rubygems
(still today) and as result you need to test the type of the metadata field
before using it in code and users are confused about when to use a list or a
string.


Map Identifiers to Source Files
'''''''''''''''''''''''''''''''

File-level notices are not considered as part of the scope of this PEP and the
existing ``SPDX-License-Identifier`` [#spdxids]_ convention can be used and
may not need further specification as a PEP.


Don't Require Compatibility with a Specific SPDX Version
''''''''''''''''''''''''''''''''''''''''''''''''''''''''

This PEP could omit specifying a specific SPDX specification version,
or one for the list of valid license identifiers, which would allow
more flexible updates as the specification evolves without another
PEP or equivalent.

However, serious concerns were expressed about a future SPDX update breaking
compatibility with existing expressions and identifiers, leaving current
packages with invalid metadata per the definition in this PEP. Requiring
compatibility with a specific version of these specifications here
and requiring a PEP or similar process to update it avoids that from
occurring, and follows the practice of other packaging ecosystems.

Therefore, it was decided [#spdxversion]_ to specify a minimum version
and requires tools to be compatible with it, while still allowing updates
so long as they don't break backward compatibility. This enables
tools to immediate take advantage of improvements and accept new
licenses, but also remain backwards compatible with the version
specified here, balancing flexibility and compatibility.


Appendix 1. License Expression Examples
=======================================

Basic Example
-------------

The Setuptools project itself, as of version 59.1.1 [#setuptools5911]_,
does not use the ``License`` field in its own project metadata.
Further, it not longer explictly specifies ``license_file``/``license_files``
as it did previously, since ``setuptools`` relies on its own automatic
inclusion of license-related files matching common patterns,
such as the ``LICENSE`` file it uses.

It only includes the following license-related metadata in its ``setup.cfg``::

    [metadata]
    classifiers =
        License :: OSI Approved :: MIT License

The simplest migration to this PEP would consist of using this instead::

    [metadata]
    license_expression = MIT

Or, in a PEP 621 ``pyproject.toml``::

    [project]
    license-expression = "MIT"

The output core metadata for the package would then be::

    License-Expression: MIT
    License-File: LICENSE

The ``LICENSE`` file would be stored at ``/setuptools-{version}/LICENSE``
in the sdist and ``/setuptools-{version}.dist-info/license_files/LICENSE``
in the wheel, and unpacked from there into the site directory (e.g.
``site-packages) on installation; ``/`` is the root of the respective archive
and ``{version}`` the version of the Setuptools project in the core metadata.


Advanced Example
----------------

Suppose Setuptools were to include the licenses of the third-party packages
that are vendored in the ``setuptools/_vendor/`` and ``pkg_resources/_vendor``
directories; specifically::

    packaging==21.2
    pyparsing==2.2.1
    ordered-set==3.1.1
    more_itertools==8.8.0

The license expressions for these packages are::

    packaging: Apache-2.0 OR BSD-2-Clause
    pyparsing: MIT
    ordered-set: MIT
    more_itertools: MIT

A comprehensive license expression covering both ``setuptools``
proper and its vendored dependencies would contain these metadata,
combining all the license expressions into one. Such an expression might be::

    MIT AND (Apache-2.0 OR BSD-2-Clause)

In addition, per the requirements of the licenses, the relevant license files
must be included in the package. Suppose the ``LICENSE`` file contains the text
of the MIT license and the copyrights used by ``setuptools``, ``pyparsing``,
``more_itertools`` and ``ordered-set``; and the ``LICENSE`` files in the
``setuptools/_vendor/packaging/`` directory contain the Apache 2.0 and
2-clause BSD license text, and the Packaging copyright statement and
license choice notice [#packlic]_.

Therefore, we assume the license files are located at the following
paths in the project source tree (relative to the project root and
``pyproject.toml``)::

    LICENSE
    setuptools/_vendor/packaging/LICENSE
    setuptools/_vendor/packaging/LICENSE.APACHE
    setuptools/_vendor/packaging/LICENSE.BSD

Putting it all together, our ``setup.cfg`` would be::

    [metadata]
    license_expression = MIT AND (Apache-2.0 OR BSD-2-Clause)
    license_files =
        LICENSE
        setuptools/_vendor/packaging/LICENSE
        setuptools/_vendor/packaging/LICENSE.APACHE
        setuptools/_vendor/packaging/LICENSE.BSD

In a PEP 621 ``pyproject.toml``, with license files specified explicitly
via the ``paths`` key, this would look like::

    [project]
    license-expression = "MIT AND (Apache-2.0 OR BSD-2-Clause)"
    license-files.paths = [
        "LICENSE",
        "setuptools/_vendor/LICENSE",
        "setuptools/_vendor/LICENSE.APACHE",
        "setuptools/_vendor/LICENSE.BSD",
    ]

Or alternatively, matched via glob patterns, this could be::

    [project]
    license-expression = "MIT AND (Apache-2.0 OR BSD-2-Clause)"
    license-files.globs = [
        "LICENSE*",
        "setuptools/_vendor/LICENSE*",
    ]

With either approach, the resulting core metadata would be::

    License-Expression: MIT AND (Apache-2.0 OR BSD-2-Clause)
    License-File: LICENSE
    License-File: setuptools/_vendor/packaging/LICENSE
    License-File: setuptools/_vendor/packaging/LICENSE.APACHE
    License-File: setuptools/_vendor/packaging/LICENSE.BSD

In the resulting sdist, with ``/`` as the root of the archive and ``{version}``
the version of the Setuptools project specified in the core metadata,
the license files would be located at the paths::

    /setuptools-{version}/LICENSE
    /setuptools-{version}/setuptools/_vendor/packaging/LICENSE
    /setuptools-{version}/setuptools/_vendor/packaging/LICENSE.APACHE
    /setuptools-{version}/setuptools/_vendor/packaging/LICENSE.BSD

In the built wheel, with ``/`` being the root of the archive and
``{version}`` as above, the license files would be stored at::

    /setuptools-{version}.dist-info/license_files/LICENSE
    /setuptools-{version}.dist-info/license_files/setuptools/_vendor/packaging/LICENSE
    /setuptools-{version}.dist-info/license_files/setuptools/_vendor/packaging/LICENSE.APACHE
    /setuptools-{version}.dist-info/license_files/setuptools/_vendor/packaging/LICENSE.BSD

Finally, in the installed project, with ``site-packages`` being the site dir
and ``{version}`` as above, the license files would be installed to::

    site-packages/setuptools-{version}.dist-info/license_files/LICENSE
    site-packages/setuptools-{version}.dist-info/license_files/setuptools/_vendor/packaging/LICENSE
    site-packages/setuptools-{version}.dist-info/license_files/setuptools/_vendor/packaging/LICENSE.APACHE
    site-packages/setuptools-{version}.dist-info/license_files/setuptools/_vendor/packaging/LICENSE.BSD


Conversion Example
------------------

Suppose we were to return to our simple ``setuptools`` case.
Per the specification, given it only has the following license classifier::

    Classifier: License :: OSI Approved :: MIT License

And no value for the ``License`` field; or, equivalently, a value of::

    License: MIT

Then the suggested value for a ``License-Expression`` field would be::

    License-Expression: MIT

For the more complex case, assuming it was currently expressed as multiple
license classifiers, no automatic conversion could be performed due to the
inherent ambiguity, and the user would be prompted on how to handle the
situation themselves.


Expression Examples
-------------------

Some additional examples of valid ``License-Expression`` values::

    License-Expression: MIT

    License-Expression: BSD-3-Clause

    License-Expression: MIT OR GPL-2.0-or-later OR (FSFUL AND BSD-2-Clause)

    License-Expression: GPL-3.0-only WITH Classpath-Exception-2.0 OR BSD-3-Clause

    License-Expression: LicenseRef-Public-Domain OR CC0-1.0 OR Unlicense

    License-Expression: LicenseRef-Proprietary


Appendix 2. License Documentation in Python
===========================================

There are multiple ways used or recommended to document Python package
licenses today. The most common are listed below.


Core Metadata
-------------

There are two overlapping core metadata fields to document a license: the
license-related ``Classifier`` strings [#classif]_ prefixed with ``License ::``
and the ``License`` field as free text [#licfield]_.

The core metadata documentation ``License`` field documentation is currently::

    License
    =======

    .. versionadded:: 1.0

    Text indicating the license covering the distribution where the license
    is not a selection from the "License" Trove classifiers. See
    :ref:`"Classifier" <metadata-classifier>` below.
    This field may also be used to specify a
    particular version of a license which is named via the ``Classifier``
    field, or to indicate a variation or exception to such a license.

    Examples::

        License: This software may only be obtained by sending the
                author a postcard, and then the user promises not
                to redistribute it.

        License: GPL version 3, excluding DRM provisions

Even though there are two fields, it is at times difficult to convey anything
but simpler licensing. For instance, some classifiers lack precision
(GPL without a version) and when multiple license-related classifiers are
listed, it is not clear if both licenses must apply, or the user may choose
between them. Furthermore, the list of available license-related classifiers
is often out-of-date.


Setuptools and Wheels
---------------------

Beyond a license code or qualifier, license text files are documented and
included in a built package either implicitly or explicitly and this is another
possible source of confusion:

- In Setuptools [#setuptoolssdist]_ and wheels [#wheels]_, license files
  are automatically added to the distribution (at their source location in
  in a source distribution/sdist, and in the ``.dist-info`` directory
  of a built wheel) if they match one of a number of common license file
  name patterns (``LICEN[CS]E*``, ``COPYING*``, ``NOTICE*`` and ``AUTHORS*``).
  Alternatively, a package author can specify a list of license file paths to
  include in the built wheel under the ``license_files`` key in the
  ``[metadata]`` section of the project's ``setup.cfg``, or as an argument
  to the ``setuptools`` ``setup()`` function. At present, following wheel's
  lead, Setuptools flattens the collected license files into the metadata
  directory, clobbering files with the same name, but there is a desire to
  resolve this, contingent on the this PEP being accepted [#setuptoolsfiles]_.

- Both tools also support an older, singular ``license_file`` parameter that
  allows specifying only one license file to add to the distribution, which
  has been deprecated for some time but still sees some use.
  See [#pipsetup]_ for instance.

- Following the publication of an earlier draft of this PEP, ``setuptools``
  added support for ``License-File`` in package metadata as described herein
  [#setuptoolspep639]_. This allows other tools consuming the resulting
  metadata to unambiguously locate the license file(s) for a given package.

**Note:** the ``License-File`` field proposed in this PEP already exists in
``wheel`` and ``setuptools`` with the same behaviour as explained above.
This PEP is only recognizing and documenting the existing practice as used
in ``wheel`` and ``setuptools`` to add license files to the distribution,
and formally including their paths in core metadata (which has since been
implemented on the basis of a draft of this PEP).


PyPA Packaging Guide and Sample Project
---------------------------------------

Both the PyPA beginner packaging tutorial [#packagingtuttxt]_ and its more
comprehensive packaging guide [#packagingguidetxt]_ state that it is important
that every package include a license file. They point to the ``LICENSE.txt``
in the official PyPA sample project as an example, which is explicitly listed
under the ``license_files`` key in its ``setup.cfg`` [#samplesetupcfg]_,
following existing practice formally specified by this PEP.

Both the beginner packaging tutorial [#packagingtutkey]_ and the sample project
[#samplesetuppy]_ only use classifiers to declare a package's license, and do
not include or mention the ``license`` field. The full packaging guide does
mention this field, but states that authors should use the license classifiers
instead, unless the project uses a non-standard license (which the guide
discourages) [#licfield]_.


Python Source Code Files
------------------------

**Note:** Documenting licenses in source code is not in the scope of this PEP.

Beside using comments and/or ``SPDX-License-Identifier`` conventions, the license
is sometimes documented in Python code files using "dunder" variables typically
named after one of the lower cased Core Metadata fields such as ``__license__``
[#pycode]_.

This convention (dunder global variables) is recognized by the built-in ``help()``
function and the standard ``pydoc`` module. The dunder variable(s) will show up in
the ``help()`` DATA section for a module.


Other Python Packaging Tools
----------------------------

- Conda package manifests [#conda]_ have support for ``license`` and
  ``license_file`` fields, and automatically include license files
  following similar naming patterns as ``wheel`` and ``setuptools``.

- Flit [#flit]_ recommends using classifiers instead of the ``License`` field
  (per the current PyPA packaging guide).

- PBR [#pbr]_ uses similar data as setuptools, but always stored in
  ``setup.cfg``.

- Poetry [#poetry]_ specifies the use of the ``license`` field in
  ``pyproject.toml`` with SPDX license identifiers.


Appendix 3. License Documentation in Other Projects
===================================================

Here is a survey of how things are done elsewhere.


Linux Distribution Packages
---------------------------

**Note:** in most cases the license texts of the most common licenses are included
globally once in a shared documentation directory (e.g. ``/usr/share/doc``).

- Debian documents package licenses with machine readable copyright files
  [#dep5]_. This specification defines its own license expression syntax that is
  very similar to the SDPX syntax and use its own list of license identifiers
  for common licenses (also closely related to SPDX identifiers).

- Fedora packages [#fedora]_ specify how to include ``License Texts``
  [#fedoratext]_ and how use a ``License`` field [#fedoralic]_ that must be filled
  with an appropriate license Short License identifier(s) from an extensive list
  of "Good Licenses" identifiers [#fedoralist]_. Fedora also defines its own
  license expression syntax very similar to the SDPX syntax.

- openSUSE packages [#opensuse]_ use SPDX license expressions with
  SPDX license identifiers and a list of extra license identifiers
  [#opensuselist]_.

- Gentoo ebuild uses a ``LICENSE`` variable [#gentoo]_. This field is specified
  in GLEP-0023 [#glep23]_ and in the Gentoo development manual [#gentoodev]_.
  Gentoo also defines a license expression syntax and a list of allowed
  licenses. The expression syntax is rather different from SPDX.

- FreeBSD package Makefile [#freebsd]_ provides ``LICENSE`` and
  ``LICENSE_FILE`` fields with a list of custom license symbols. For
  non-standard licenses, FreeBSD recommend to use ``LICENSE=UNKNOWN`` and add
  ``LICENSE_NAME`` and ``LICENSE_TEXT`` fields, as well as sophisticated
  ``LICENSE_PERMS`` to qualify the license permissions and ``LICENSE_GROUPS``
  to document a license grouping. The ``LICENSE_COMB`` allows to document more
  than one license and how they apply together, forming a custom license
  expression syntax. FreeBSD also recommends the use of
  ``SPDX-License-Identifier`` in source code files.

- Arch Linux PKGBUILD [#archinux]_ define its own license identifiers
  [#archlinuxlist]_. The value ``'unknown'`` can be used if the license is not
  defined.

- OpenWRT ipk packages [#openwrt]_ use the ``PKG_LICENSE`` and
  ``PKG_LICENSE_FILES`` variables and recommend the use of SPDX License
  identifiers.

- NixOS uses SPDX identifiers [#nixos]_ and some extra license identifiers in
  its license field.

- GNU Guix (based on NixOS) has a single License field, uses its own license
  symbols list [#guix]_ and specifies to use one license or a list of licenses
  [#guixlic]_.

- Alpine Linux packages [#alpine]_ recommend using SPDX identifiers in the
  license field.


Language and Application Packages
---------------------------------

- In Java, Maven POM [#maven]_ defines a ``licenses`` XML tag with a list of license
  items each with a name, URL, comments and "distribution" type. This is not
  mandatory and the content of each field is not specified.

- JavaScript npm package.json [#npm]_ use a single license field with SPDX
  license expression or the ``UNLICENSED`` id if no license is specified.
  A license file can be referenced as an alternative using "SEE LICENSE IN
  <filename>" in the single ``license`` field.

- Rubygems gemspec [#gem]_ specifies either a singular license string or a list
  of license strings. The relationship between multiple licenses in a list is
  not specified. They recommend using SPDX license identifiers.

- CPAN Perl modules [#perl]_ use a single license field which is either a single
  string or a list of strings. The relationship between the licenses in a list
  is not specified. There is a list of custom license identifiers plus
  these generic identifiers: ``open_source``, ``restricted``, ``unrestricted``,
  ``unknown``.

- Rust Cargo [#cargo]_ specifies the use of an SPDX license expression (v2.1) in
  the ``license`` field. It also supports an alternative expression syntax using
  slash-separated SPDX license identifiers. There is also a ``license_file``
  field. The crates.io package registry [#cratesio]_ requires that either
  ``license`` or ``license_file`` fields are set when you upload a package.

- PHP Composer composer.json [#composer]_ uses a ``license`` field with an SPDX
  license id or "proprietary". The ``license`` field is either a single string
  that can use something which resembles the SPDX license expression syntax with
  "and" and "or" keywords; or is a list of strings if there is a choice of
  licenses (aka. a "disjunctive" choice of license).

- NuGet packages [#nuget]_ were using only a simple license URL and are now
  specifying to use an SPDX License expression and/or the path to a license
  file within the package. The NuGet.org repository states that they only
  accepts license expressions that are `approved by the Open Source Initiative
  or the Free Software Foundation.`

- Go language modules ``go.mod`` have no provision for any metadata beyond
  dependencies. Licensing information is left for code authors and other
  community package managers to document.

- Dart/Flutter spec [#flutter]_ recommends to use a single ``LICENSE`` file
  that should contain all the license texts each separated by a line with 80
  hyphens.

- JavaScript Bower [#bower]_ ``license`` field is either a single string or a list
  of strings using either SPDX license identifiers, or a path or a URL to a
  license file.

- Cocoapods podspec [#cocoapod]_ ``license`` field is either a single string or a
  mapping with attributes of type, file and text keys. This is mandatory unless
  there is a LICENSE or LICENCE file provided.

- Haskell Cabal [#cabal]_ accepts an SPDX license expression since version 2.2.
  The version of the SPDX license list used is a function of the ``cabal`` version.
  The specification also provides a mapping between pre-SPDX Legacy license
  Identifiers and SPDX identifiers. Cabal also specifies a ``license-file(s)``
  field that lists license files that will be installed with the package.

- Erlang/Elixir mix/hex package [#mix]_ specifies a ``licenses`` field as a
  required list of license strings and recommends to use SPDX license
  identifiers.

- D lang dub package [#dub]_ defines its own list of license identifiers and
  its own license expression syntax and both are similar to the SPDX conventions.

- R Package DESCRIPTION [#cran]_ defines its own sophisticated license
  expression syntax and list of licenses identifiers. R has a unique way to
  support specifiers for license versions such as ``LGPL (>= 2.0, < 3)`` in its
  license expression syntax.


Other Ecosystems
----------------

- ``SPDX-License-Identifier`` [#spdxids]_ is a simple convention to document the
  license inside a file.

- The Free Software Foundation (FSF) promotes the use of SPDX license identifiers
  for clarity in the GPL and other versioned free software licenses [#gnu]_
  [#fsf]_.

- The Free Software Foundation Europe (FSFE) REUSE project [#reuse]_ promotes
  using ``SPDX-License-Identifier``.

- The Linux kernel uses ``SPDX-License-Identifier`` and parts of the FSFE REUSE
  conventions to document its licenses [#linux]_.

- U-Boot spearheaded using ``SPDX-License-Identifier`` in code and now follows the
  Linux ways [#uboot]_.

- The Apache Software Foundation projects use RDF DOAP [#apache]_ with a single
  license field pointing to SPDX license identifiers.

- The Eclipse Foundation promotes using ``SPDX-license-Identifiers`` [#eclipse]_

- The ClearlyDefined project [#cd]_ promotes using SPDX license identifiers and
  expressions to improve license clarity.

- The Android Open Source Project [#android]_ use ``MODULE_LICENSE_XXX`` empty
  tag files where ``XXX`` is a license code such as BSD, APACHE, GPL, etc. And
  side by side with this ``MODULE_LICENSE`` file there is a ``NOTICE`` file
  that contains license and notices texts.


References
==========

.. [#cms] https://packaging.python.org/specifications/core-metadata
.. [#projectspec] https://packaging.python.org/specifications/declaring-project-metadata/
.. [#sdistspec] https://packaging.python.org/specifications/source-distribution-format/
.. [#wheelspec] https://packaging.python.org/specifications/binary-distribution-format/
.. [#installedspec] https://packaging.python.org/specifications/recording-installed-packages/
.. [#cdstats] https://clearlydefined.io/stats
.. [#cd] https://clearlydefined.io
.. [#osi] https://opensource.org
.. [#classif] https://pypi.org/classifiers
.. [#classifersrepo] https://github.com/pypa/trove-classifiers
.. [#issue17] https://github.com/pypa/trove-classifiers/issues/17
.. [#badclassifiers] https://github.com/pypa/trove-classifiers/issues/17#issuecomment-385027197
.. [#setuptoolspep639] https://github.com/pypa/setuptools/pull/2645
.. [#wheelfiles] https://github.com/pypa/wheel/issues/138
.. [#setuptoolsfiles] https://github.com/pypa/setuptools/issues/2739
.. [#globmodule] https://docs.python.org/3/library/glob.html
.. [#spdxlist] https://spdx.org/licenses/
.. [#spdx] https://spdx.dev/
.. [#spdx22] https://spdx.github.io/spdx-spec/SPDX-license-expressions/
.. [#wheels] https://github.com/pypa/wheel/blob/0.37.0/docs/user_guide.rst#including-license-files-in-the-generated-wheel-file
.. [#reuse] https://reuse.software/
.. [#licexp] https://github.com/nexB/license-expression/
.. [#spdxpy] https://github.com/spdx/tools-python/
.. [#reusediscussion] https://github.com/pombredanne/spdx-pypi-pep/issues/7
.. [#choosealicense] https://choosealicense.com/
.. [#spdxversion] https://github.com/pombredanne/spdx-pypi-pep/issues/6
.. [#scancodetk] https://github.com/nexB/scancode-toolkit
.. [#licfield] https://packaging.python.org/guides/distributing-packages-using-setuptools/#license
.. [#samplesetuppy] https://github.com/pypa/sampleproject/blob/3a836905fbd687af334db16b16c37cf51dcbc99c/setup.py#L98
.. [#samplesetupcfg] https://github.com/pypa/sampleproject/blob/3a836905fbd687af334db16b16c37cf51dcbc99c/setup.cfg
.. [#pipsetup] https://github.com/pypa/pip/blob/21.3.1/setup.cfg#L114
.. [#setuptoolssdist] https://github.com/pypa/setuptools/pull/1767
.. [#packagingtuttxt] https://packaging.python.org/tutorials/packaging-projects/#creating-a-license
.. [#packagingguidetxt] https://packaging.python.org/guides/distributing-packages-using-setuptools/#license-txt
.. [#packagingtutkey] https://packaging.python.org/tutorials/packaging-projects/#configuring-metadata
.. [#pycode] https://github.com/search?l=Python&q=%22__license__%22&type=Code
.. [#setuptools5911] https://github.com/pypa/setuptools/blob/v59.1.1/setup.cfg
.. [#packlic] https://github.com/pypa/packaging/blob/21.2/LICENSE
.. [#conda] https://docs.conda.io/projects/conda-build/en/stable/resources/define-metadata.html#about-section
.. [#flit] https://flit.readthedocs.io/en/stable/pyproject_toml.html
.. [#poetry] https://python-poetry.org/docs/pyproject/#license
.. [#pbr] https://docs.openstack.org/pbr/latest/user/features.html
.. [#dep5] https://dep-team.pages.debian.net/deps/dep5/
.. [#fedora] https://docs.fedoraproject.org/en-US/packaging-guidelines/LicensingGuidelines/
.. [#fedoratext] https://docs.fedoraproject.org/en-US/packaging-guidelines/LicensingGuidelines/#_license_text
.. [#fedoralic] https://docs.fedoraproject.org/en-US/packaging-guidelines/LicensingGuidelines/#_valid_license_short_names
.. [#fedoralist] https://fedoraproject.org/wiki/Licensing:Main?rd=Licensing#Good_Licenses
.. [#opensuse] https://en.opensuse.org/openSUSE:Packaging_guidelines#Licensing
.. [#opensuselist] https://docs.google.com/spreadsheets/d/14AdaJ6cmU0kvQ4ulq9pWpjdZL5tkR03exRSYJmPGdfs/pub
.. [#gentoo] https://devmanual.gentoo.org/ebuild-writing/variables/index.html#license
.. [#glep23] https://www.gentoo.org/glep/glep-0023.html
.. [#gentoodev] https://devmanual.gentoo.org/general-concepts/licenses/index.html
.. [#freebsd] https://docs.freebsd.org/en/books/porters-handbook/makefiles/#licenses
.. [#archinux] https://wiki.archlinux.org/title/PKGBUILD#license
.. [#archlinuxlist] https://archlinux.org/packages/core/any/licenses/files/
.. [#openwrt] https://openwrt.org/docs/guide-developer/packages#buildpackage_variables
.. [#nixos] https://github.com/NixOS/nixpkgs/blob/21.05/lib/licenses.nix
.. [#guix] https://git.savannah.gnu.org/cgit/guix.git/tree/guix/licenses.scm?h=v1.3.0
.. [#guixlic] https://guix.gnu.org/manual/en/html_node/package-Reference.html#index-license_002c-of-packages
.. [#alpine] https://wiki.alpinelinux.org/wiki/Creating_an_Alpine_package#license
.. [#maven] https://maven.apache.org/pom.html#Licenses
.. [#npm] https://docs.npmjs.com/cli/v8/configuring-npm/package-json#license
.. [#gem] https://guides.rubygems.org/specification-reference/#license=
.. [#perl] https://metacpan.org/pod/CPAN::Meta::Spec#license
.. [#cargo] https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata
.. [#cratesio] https://doc.rust-lang.org/cargo/reference/registries.html#publish
.. [#composer] https://getcomposer.org/doc/04-schema.md#license
.. [#nuget] https://docs.microsoft.com/en-us/nuget/reference/nuspec#licenseurl
.. [#flutter] https://flutter.dev/docs/development/packages-and-plugins/developing-packages#adding-licenses-to-the-license-file
.. [#bower] https://github.com/bower/spec/blob/b00c4403e22e3f6177c410ed3391b9259687e461/json.md#license
.. [#cocoapod] https://guides.cocoapods.org/syntax/podspec.html#license
.. [#cabal] https://cabal.readthedocs.io/en/3.6/cabal-package.html?highlight=license#pkg-field-license
.. [#mix] https://hex.pm/docs/publish
.. [#dub] https://dub.pm/package-format-json.html#licenses
.. [#cran] https://cran.r-project.org/doc/manuals/r-release/R-exts.html#Licensing
.. [#spdxids] https://spdx.dev/resources/use/#identifiers
.. [#gnu] https://www.gnu.org/licenses/identify-licenses-clearly.html
.. [#fsf] https://www.fsf.org/blogs/rms/rms-article-for-claritys-sake-please-dont-say-licensed-under-gnu-gpl-2
.. [#linux] https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/process/license-rules.rst
.. [#uboot] https://www.denx.de/wiki/U-Boot/Licensing
.. [#apache] https://svn.apache.org/repos/asf/allura/doap_Allura.rdf
.. [#eclipse] https://www.eclipse.org/legal/epl-2.0/faq.php
.. [#android] https://github.com/aosp-mirror/platform_external_tcpdump/blob/android-platform-12.0.0_r1/MODULE_LICENSE_BSD
.. [#cc0] https://creativecommons.org/publicdomain/zero/1.0/
.. [#unlic] https://unlicense.org/


Copyright
=========

This document is placed in the public domain or under the CC0-1.0-Universal
license [#cc0]_, whichever is more permissive.


Acknowledgments
===============

- Nick Coghlan
- Kevin P. Fleming
- Pradyun Gedam
- Oleg Grenrus
- Dustin Ingram
- Chris Jerdonek
- Cyril Roelandt
- Luis Villa



..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 80
   End:
